/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: danmars (https://sketchfab.com/danmars)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/xbot-4000-68984079c93048d88d062add5526ba29
Title: XBOT 4000
*/

import * as THREE from "three";

import { ForwardedRef, forwardRef } from "react";
import { GLTF } from "three-stdlib";

import { useGLTF } from "@react-three/drei";
import { useThree } from "@react-three/fiber";

import { SCENE_MARGIN_TOP } from "./ScrollableScene";

type GLTFResult = GLTF & {
  nodes: {
    ROBOT_LOWPOLY_lambert2_0: THREE.Mesh;
  };
  materials: {
    lambert2: THREE.MeshStandardMaterial;
  };
};

interface Props {
  scale?: [x: number, y: number, z: number] | number;
}
const Xbot = (
  props: JSX.IntrinsicElements["group"] & Props,
  ref: ForwardedRef<THREE.Group>,
) => {
  const { scale } = props;

  const { nodes, materials } = useGLTF("/assets/xbot_4000.glb") as GLTFResult;
  const { viewport } = useThree();

  const xbotGeom = nodes.ROBOT_LOWPOLY_lambert2_0.geometry;

  xbotGeom.center();
  xbotGeom.computeBoundingBox();

  const scaleY = Array.isArray(scale) ? scale[1] : scale;
  const yScalingFactor = scaleY ?? 1;
  const xbotHeight =
    (xbotGeom.boundingBox!.max!.y - xbotGeom.boundingBox!.min!.y) *
    yScalingFactor;

  const xbotY = 0 - xbotHeight / 2 + viewport.height / 2 - SCENE_MARGIN_TOP;

  return (
    <group {...props} ref={ref} dispose={null} position={[0, xbotY, 0]}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.ROBOT_LOWPOLY_lambert2_0.geometry}
        material={materials.lambert2}
      />
    </group>
  );
};

useGLTF.preload("/assets/xbot_4000.glb");

export default forwardRef(Xbot);
